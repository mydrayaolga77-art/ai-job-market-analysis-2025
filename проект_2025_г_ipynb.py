# -*- coding: utf-8 -*-
"""Проект 2025 г.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xceA-5l1YgAwFZRG3r7UzgXiBWr0C1cn

ПРОЕКТ
"""

import numpy as np
from scipy import stats
import logging
import sys
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
!pip install reportlab
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, LongTable, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
import smtplib
from email.message import EmailMessage

import kagglehub


path = kagglehub.dataset_download("bismasajjad/global-ai-job-market-and-salary-trends-2025")

print("Файлы скачаны в:", path)

pd.read_csv(f"{path}/ai_job_dataset.csv")

df = pd.read_csv(f"{path}/ai_job_dataset.csv")

df.info()

df.head(20)

df.describe()

def validate_missing_data(df):
    missing_report = df.isnull().sum()
    missing_percent = (missing_report / len(df)) * 100

    # Формируем отчет
    for col in df.columns:
        if missing_report[col] > 0:
            logging.info(f"Столбец '{col}': {missing_report[col]} пропусков ({missing_percent[col]:.2f}%)")


    df_cleaned = df.dropna()
    logging.info(f"Обработка пропусков завершена. Удалено строк: {len(df) - len(df_cleaned)}")
    return df_cleaned

def validate_data_types(df):
    logging.info("Проверка корректности типов данных...")

    # 1. Авто-конвертация дат (если в названии есть 'year' или 'date')
    for col in df.columns:
        if 'year' in col.lower() or 'date' in col.lower():
            df[col] = pd.to_datetime(df[col], errors='coerce')
            logging.info(f"Тип столбца '{col}' приведен к DateTime")

    return df

print("--- Запуск валидации данных 2025 ---")

df = validate_data_types(df)

df_cleaned = validate_missing_data(df)

print("\n" + "="*40)
print("ФИНАЛЬНЫЙ ОТЧЕТ ПОСЛЕ ОЧИСТКИ")
print("="*40)

print(f"Строк до обработки: {len(df)}")
print(f"Строк после обработки: {len(df_cleaned)}")
print(f"Удалено записей: {len(df) - len(df_cleaned)}")

print("\nТекущие типы столбцов:")
print(df_cleaned.dtypes)

print("\nПервые 5 строк очищенных данных:")
display(df_cleaned.head())
print("="*40)

logging.basicConfig(level=logging.INFO)

df = validate_data_types(df)      
df = validate_missing_data(df)    

print("\nИтоговая информация о типах:")
print(df.dtypes)

def handle_outliers_iqr(df, salary_usd):
    Q1 = df[salary_usd].quantile(0.25)
    Q3 = df[salary_usd].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    outliers = df[(df[salary_usd] < lower_bound) | (df[salary_usd] > upper_bound)]
    df_clean = df[(df[salary_usd] >= lower_bound) & (df[salary_usd] <= upper_bound)]

    print(f"--- АНАЛИЗ ВЫБРОСОВ ({salary_usd}) ---")
    print(f"Минимум: {df[salary_usd].min():.2f}, Максимум: {df[salary_usd].max():.2f}")
    print(f"Границы (IQR): {lower_bound:.2f} до {upper_bound:.2f}")
    print(f"Найдено аномалий: {len(outliers)}")
    print(f"Удалено строк: {len(df) - len(df_clean)}")
    print("-" * 30)

    return df_clean

print("Статистика ДО очистки:")
print(df['salary_usd'].describe())

df = handle_outliers_iqr(df, 'salary_usd')

print("\nСтатистика ПОСЛЕ очистки:")
print(df['salary_usd'].describe())

def handle_outliers_zscore(df, salary_usd, threshold=3):
    data_series = df[salary_usd].dropna()

    z_scores = np.abs(stats.zscore(data_series))

    #filtered_entries = z_scores < threshold
    keep_mask = z_scores < threshold

    valid_indices = data_series.index[keep_mask]

    df_clean = df.loc[valid_indices]

    removed = len(df) - len(df_clean)
    logging.info(f"Z-score [{salary_usd}]: Удалено {removed} экстремальных значений (порог {threshold}σ)")
    return df_clean

df_final = handle_outliers_zscore(df, 'salary_usd')

print("\n=== ИТОГ ОБРАБОТКИ ВЫБРОСОВ ===")
print(f"Строк до: {len(df)}")
print(f"Строк после: {len(df_final)}")
print(f"Максимальная зарплата после очистки: {df_final['salary_usd'].max():,.0f} USD")
print("-" * 30)

logging.basicConfig(level=logging.INFO)

df = handle_outliers_iqr(df, 'salary_usd')

if 'remote_ratio' in df.columns:
    df = handle_outliers_zscore(df, 'remote_ratio')

print(f"Итоговое количество чистых строк для анализа: {len(df)}")

def validate_and_log_all(df):
    initial_rows = df.shape[0]
    initial_shape = df.shape

    print("=== НАЧАЛО ВАЛИДАЦИИ ДАТАСЕТА ===")

    try:
        df = validate_data_types(df)
        df = validate_missing_data(df)
        if 'salary_usd' in df.columns:
            df = handle_outliers_zscore(df, 'salary_usd')
    except NameError as e:
        print(f"ОШИБКА: Одна из функций не определена: {e}")
        return df

    final_rows = df.shape[0]
    final_shape = df.shape

    rows_lost = initial_rows - final_rows
    loss_percent = (rows_lost / initial_rows * 100) if initial_rows > 0 else 0

    print("\n" + "="*35)
    print("=== ИТОГОВЫЙ ОТЧЕТ ВАЛИДАЦИИ ===")
    print(f"Исходный размер:  {initial_shape}")
    print(f"Финальный размер: {final_shape}")
    print(f"Всего удалено строк: {rows_lost} ({loss_percent:.2f}%)")
    print("Статус: ДАННЫЕ ГОТОВЫ К АНАЛИЗУ")
    print("="*35)

    return df

try:
    df_clean = validate_and_log_all(df)
except NameError:
    print("Ошибка: Исходный датасет 'df' не найден. Загрузите его перед запуском.")

def final_preprocessing(df):
    print("--- Запуск полной обработки ---")

    duplicates = df.duplicated().sum()
    df = df.drop_duplicates()
    print(f"Удалено дубликатов: {duplicates}")

    for col in df.select_dtypes(include=[np.number]).columns:
        if df[col].isnull().sum() > 0:
            median_val = df[col].median()
            df[col] = df[col].fillna(median_val)
            print(f"Пропуски в '{col}' заполнены медианой: {median_val}")

    for col in df.select_dtypes(include=['object']).columns:
        if df[col].nunique() < 16: # Кодируем только если мало уникальных значений
            df[col] = df[col].astype('category').cat.codes
            print(f"Столбец '{col}' закодирован в числа")

    if 'salary_usd' in df.columns:
        col_min = df['salary_usd'].min()
        col_max = df['salary_usd'].max()
        df['Salary_Scaled'] = (df['salary_usd'] - col_min) / (col_max - col_min)
        print("Добавлен столбец 'Salary_Scaled' (масштаб 0-1)")

    print("--- Обработка завершена ---")
    return df

df_final = final_preprocessing(df_cleaned)
display(df_final.head())


encoded_columns = [
    'salary_usd', 'remote_ratio', 'experience_level', 'employment_type',
    'company_size', 'education_required', 'industry', 'salary_currency'
]

stats_summary = df_final[encoded_columns].describe().round(2).T
print("=== ИТОГОВАЯ СТАТИСТИКА ПО ЗАКОДИРОВАННЫМ ПРИЗНАКАМ ===")
display(stats_summary)

cols_to_map = ['experience_level', 'employment_type', 'company_size', 'salary_currency', 'education_required', 'industry']

print("=== РАСШИФРОВКА КОДОВ (MAPPING) ===\n")

for col in cols_to_map:
    if col in df.columns:
        mapping = dict(enumerate(df[col].astype('category').cat.categories))

        print(f"Столбец: {col}")
        print("-" * 30)
        # Выводим в колонку: Код -> Значение
        for code, label in mapping.items():
            print(f"  {code} : {label}")
        print("-" * 30 + "\n")

df_final['month'] = df_final['posting_date'].dt.month
df_final['quarter'] = df_final['posting_date'].dt.quarter
df_final['month_name'] = df_final['posting_date'].dt.month_name()

print("Временные признаки успешно добавлены.")

trend_data = df_final.groupby('month').agg({
    'salary_usd': 'mean',
    'job_id': 'count'
}).rename(columns={'job_id': 'vacancies_count'}).round(2)

print("=== ТРЕНД РЫНКА AI В 2025 ГОДУ ===")
display(trend_data)


plt.figure(figsize=(10, 5))
plt.plot(trend_data.index, trend_data['salary_usd'], marker='o', color='green', linewidth=2)
plt.title('Тренд средней зарплаты (USD) по месяцам 2025')
plt.xlabel('Месяц')
plt.ylabel('Средняя зарплата')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

seasonality = df_final.groupby('quarter').agg({
    'job_id': 'count',
    'salary_usd': 'median'
}).rename(columns={'job_id': 'total_vacancies', 'salary_usd': 'median_salary'})

print("\n=== СЕЗОННАЯ АКТИВНОСТЬ (ПО КВАРТАЛАМ) ===")
display(seasonality)

trend_by_experience = df_final.groupby(['month', 'experience_level'])['salary_usd'].mean().unstack()

trend_by_experience.columns = ['Entry', 'Executive', 'Mid', 'Senior']

print("Данные для анализа трендов по опыту подготовлены:")
display(trend_by_experience.round(2))

plt.figure(figsize=(14, 7))
sns.lineplot(data=trend_by_experience, palette='flare', linewidth=2.5, marker='o')

plt.title('Динамика зарплат в AI по уровням опыта (2025 год)', fontsize=16)
plt.xlabel('Месяц года', fontsize=12)
plt.ylabel('Средняя зарплата (USD)', fontsize=12)
plt.legend(title='Уровень опыта', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

hiring_seasonality = pd.crosstab(df_final['quarter'], df_final['experience_level'])
hiring_seasonality.columns = ['Entry', 'Executive', 'Mid', 'Senior']

print("\n=== СЕЗОННОСТЬ НАЙМА (Количество вакансий по кварталам) ===")
display(hiring_seasonality)

hiring_seasonality.plot(kind='bar', figsize=(10, 6))
plt.title('Сезонность найма в AI по кварталам 2025')
plt.ylabel('Количество вакансий')
plt.xlabel('Квартал')
plt.legend(title='Уровень опыта')
plt.xticks(rotation=0)
plt.show()

plt.figure(figsize=(12, 6))

ax = sns.boxplot(x=df_final['salary_usd'], color='skyblue')

stats = df_final['salary_usd'].describe()
q1, median, q3 = stats['25%'], stats['50%'], stats['75%']
min_val, max_val = stats['min'], stats['max']

points = [min_val, q1, median, q3, max_val]

for point in points:
    ax.text(point, -0.4, f'${point:,.0f}',
            ha='center', va='center', fontweight='bold',
            bbox=dict(facecolor='white', alpha=0.7, edgecolor='none'))

plt.title('Распределение зарплат с ключевыми метриками (2025)', fontsize=14)
plt.xlabel('Зарплата в USD')
plt.grid(axis='x', linestyle='--', alpha=0.6)

plt.ylim(-0.6, 0.5)

plt.show()

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score

features = ['experience_level', 'employment_type', 'company_size',
            'remote_ratio', 'education_required']
X = df_final[features]
y = df_final['salary_usd']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print(f"Обучающая выборка: {X_train.shape[0]} строк")
print(f"Тестовая выборка: {X_test.shape[0]} строк")

model = RandomForestRegressor(n_estimators=100, random_state=42)

model.fit(X_train, y_train)

print("Модель успешно обучена!")

y_pred = model.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print("\n=== ИТОГИ ОБУЧЕНИЯ МОДЕЛИ ===")
print(f"Средняя ошибка (MAE): ${mae:,.2f}")
print(f"Коэффициент детерминации (R2): {r2:.2f}")

new_specialist = [[2, 2, 1, 100, 1]]
predicted_salary = model.predict(new_specialist)
print(f"\nПрогноз зарплаты для Mid-специалиста: ${predicted_salary[0]:,.2f}")

importances = model.feature_importances_
feature_names = ['experience_level', 'employment_type', 'company_size',
                 'remote_ratio', 'education_required']

feature_importance_df = pd.DataFrame({
    'Признак': feature_names,
    'Важность': importances
}).sort_values(by='Важность', ascending=False)

plt.figure(figsize=(10, 6))
sns.barplot(x='Важность', y='Признак', data=feature_importance_df, palette='magma')

plt.title('Что больше всего влияет на зарплату в 2025 году?', fontsize=14)
plt.xlabel('Коэффициент важности (0 до 1)')
plt.ylabel('Факторы')
plt.grid(axis='x', linestyle='--', alpha=0.7)

plt.show()

print("Рейтинг влияния факторов:")
print(feature_importance_df.to_string(index=False))

mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print("="*40)
print("ФИНАЛЬНЫЕ МЕТРИКИ КАЧЕСТВА МОДЕЛИ (2025)")
print("="*40)
print(f"MAE (Средняя абсолютная ошибка):  ${mae:,.2f}")
print(f"RMSE (Корень из среднокв. ошибки): ${rmse:,.2f}")
print(f"R² (Коэффициент детерминации):     {r2:.4f}")
print("-" * 40)
print(f"Средняя зарплата в тесте:        ${y_test.mean():,.2f}")
print(f"Ошибка в процентах (MAE / Mean): {(mae/y_test.mean()*100):.2f}%")
print("="*40)

plt.figure(figsize=(10, 6))
sns.scatterplot(x=y_test, y=y_pred, alpha=0.5, color='teal')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2) # Идеальная линия

plt.title('Сравнение реальных зарплат и предсказаний модели (2025)', fontsize=14)
plt.xlabel('Реальная зарплата (USD)')
plt.ylabel('Предсказанная зарплата (USD)')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

def export_to_excel(df, stats_summary, filename="AI_Market_Report_2025.xlsx"):
    with pd.ExcelWriter(filename, engine='openpyxl') as writer:
        # Лист 1: Очищенные данные
        df.head(1000).to_excel(writer, sheet_name='Cleaned Data', index=False)

        # Лист 2: Статистические метрики
        stats_summary.to_excel(writer, sheet_name='Statistics')

    print(f"Отчет успешно сохранен в Excel: {filename}")

export_to_excel(df_final, stats_summary)

font_path = '/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf'

if os.path.exists(font_path):
    pdfmetrics.registerFont(TTFont('RussianFont', font_path))
    print("Шрифт найден и зарегистрирован.")
else:
    print("Шрифт не найден по указанному пути!")

def safe_pdf_export(df, filename="Final_Report_2025.pdf"):
    doc = SimpleDocTemplate(filename, pagesize=A4)
    elements = []

    styles = getSampleStyleSheet()
    for style in styles.byName.values():
        style.fontName = 'RussianFont' 

    try:
        elements.append(Paragraph("Аналитический отчет AI Job Market 2025", styles['Title']))
        elements.append(Spacer(1, 12))

        elements.append(Paragraph(f"<b>Дата отчета:</b> 30 декабря 2025 года", styles['Normal']))
        elements.append(Paragraph(f"<b>Объем данных:</b> {len(df)} записей", styles['Normal']))
        elements.append(Spacer(1, 12))

        elements.append(Paragraph("Метрики качества ML-модели:", styles['Heading2']))
        elements.append(Paragraph(f"Средняя ошибка (MAE): ${mae:,.2f}", styles['Normal']))
        elements.append(Paragraph(f"Коэффициент детерминации (R2): {r2:.2f}", styles['Normal']))
        elements.append(Spacer(1, 20))

        elements.append(Paragraph("Влияние факторов на зарплату:", styles['Heading2']))
        elements.append(Image('importance.png', width=450, height=225))
        elements.append(Spacer(1, 20))

        elements.append(PageBreak()) # Переход на новую страницу

        # --- СТРАНИЦА 2: Сезонность и Графики ---
        elements.append(Paragraph("Анализ сезонности найма:", styles['Heading2']))
        elements.append(Image('seasonality.png', width=450, height=225))
        elements.append(Spacer(1, 20))

        elements.append(Paragraph("Таблица вакансий (фрагмент):", styles['Heading2']))

        data_to_show = df[['job_title', 'experience_level', 'salary_usd']].head(50)
        table_data = [data_to_show.columns.to_list()] + data_to_show.values.tolist()

        table = LongTable(table_data, repeatRows=1)
        table.setStyle(TableStyle([
            ('FONTNAME', (0,0), (-1,-1), 'RussianFont'),
            ('BACKGROUND', (0, 0), (-1, 0), colors.cadetblue),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('FONTSIZE', (0, 0), (-1, -1), 8),
        ]))
        elements.append(table)

        doc.build(elements)
        print(f"Файл {filename} успешно создан и готов к открытию.")

    except Exception as e:
        print(f"Ошибка при создании PDF: {e}")

safe_pdf_export(df_final)

plt.figure(figsize=(8, 4))
feature_importance_df.plot(kind='barh', x='Признак', y='Важность', color='teal')
plt.title('Feature Importance 2025')
plt.tight_layout()
plt.savefig('importance.png', dpi=300)
plt.close()

plt.figure(figsize=(8, 4))
hiring_seasonality.plot(kind='bar')
plt.title('Hiring Seasonality 2025')
plt.tight_layout()
plt.savefig('seasonality.png', dpi=300)
plt.close()
